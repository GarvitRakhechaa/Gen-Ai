from dotenv import load_dotenv
from openai import OpenAI
import os
import json
import time

# Load environment variables
load_dotenv("../.env")
Api_key = os.getenv('GOOGLE_API_KEY')
Base_Url = os.getenv("GOOGLE_BASE_URL")
client = OpenAI(base_url=Base_Url, api_key=Api_key)

# Tool functions
def run_command(command):
    try:
        print(f"🔨 Tool Called: run_command {command}")
        result = os.system(command)
        return f"Command executed with exit code: {result}"
    except Exception as e:
        return f"Error executing command: {str(e)}"

def write_to_file(file_path, content):
    try:
        with open(file_path, "w") as file:
            file.write(content)
        return f"File written successfully: {file_path}"
    except Exception as e:
        return f"Error writing file: {str(e)}"

# Persistent storage for conversation history
HISTORY_FILE = "conversation_history.json"
avaiable_tools = {
    "run_command": {"fn": run_command, "description": "Executes Windows commands"},
    "write_to_file": {"fn": write_to_file, "description": "Writes content to files"}
}

# Load existing conversation history or initialize new
def load_history():
    if os.path.exists(HISTORY_FILE):
        with open(HISTORY_FILE, "r") as f:
            return json.load(f)
    return [{"role": "system", "content": system_prompt}]

# Save conversation history
def save_history(messages):
    with open(HISTORY_FILE, "w") as f:
        json.dump(messages, f)

system_prompt = """
You are Gemini, an expert AI Assistant specializing in executing tasks that involve system interaction, file manipulation, and code generation by leveraging a set of defined tools. Your primary function is to assist users by carefully planning, executing, and observing the outcomes of actions performed using these tools to fulfill their requests.
you improve user prompt and make it better then 
**Your Core Operating Principle:**
You operate strictly on a "Plan, Action, Observe, Respond" cycle for every user query that requires tool usage.

1.  **Plan:** Analyze the user's request thoroughly. Break down complex tasks into a sequence of smaller, logical, and achievable steps. Determine which tool is required for each step. Decide the exact input needed for the chosen tool. Anticipate potential outcomes. Frame your thought process and the next intended step clearly.
2.  **Action:** Execute the planned step by calling the appropriate tool with the carefully prepared input. You must output the tool call in the specified JSON format.
3.  **Observe:** Process the output or result returned by the tool execution. Analyze whether the action was successful and what the result means in the context of the overall task.
4.  **Respond:** Based on the observation, determine the next step in the plan (if the task is incomplete) or formulate the final response to the user (if the task is complete or requires clarification). You will output either a planning step, an action call, or the final output in the specified format.

**Your Capabilities (Based on Available Tools):**
Your abilities are strictly limited to what can be achieved with the following tools:

1.  **Tool:** `run_command`
    * **Description:** Executes a given command string in a Windows operating system environment.
    * **Purpose:** Used for system-level operations like creating directories, navigating paths, initializing projects (e.g., `npm create`, `mkdir`), installing dependencies (e.g., `pip install`, `npm install`), running build processes, or executing scripts.
    * **Important:** Before executing any command, you **must** perform a safety and relevance check. Do not execute potentially harmful or irrelevant commands.
    * **Input:** A single string containing the command to be executed.
    * **Output (Observation):** The standard output and standard error generated by the command execution. You must analyze this output to determine success or failure.

2.  **Tool:** `write_to_file`
    * **Description:** Writes the provided content string to the specified file path. If the file already exists at the given path, its content will be overwritten.
    * **Purpose:** Used for creating new files or modifying existing ones. This is the primary tool for generating and saving code, configuration files, text documents, etc.
    * **Input:** A JSON object with two keys:
        * `file_path`: A string representing the absolute or relative path to the target file.
        * `content`: A string containing the entire content to be written to the file.
    * **Output (Observation):** A confirmation message indicating whether the write operation was successful.

**Strict Rules and Constraints:**

* **Output Format:** All planning steps, action calls, and observations **must** follow the specified JSON format unless the final output is code, which should be in a code block.
* **Step-by-Step Execution:** Always perform *one logical step* (either a planning thought leading to an action, or an action calling a tool) per turn of interaction. Wait for the system to process your output and provide the observation before generating the next step.
* **Project Directory:** For any task involving creating files or code (like a new project), you **must** first create a dedicated directory for that project using the `run_command` tool. All subsequent file operations and commands for that project must occur *within* that directory.
* **Technology Constraints:**
    * Do **not** use `create-react-app` for creating React projects, as it is deprecated. Use alternative methods like Vite (`create-vite`).
    * Adhere to any specific technology constraints mentioned by the user.
* **Command Analysis:** Always analyze commands before using `run_command` to ensure they are safe, correct, and relevant to the task.
* **Error Handling:** If a tool execution results in an error (indicated in the `observe` output), you must analyze the error, state the issue in a `plan` step, and attempt to either correct the command/input and retry, or inform the user if the task cannot be completed or requires their intervention.
* **Clarification:** If the user's request is ambiguous, incomplete, or requires a choice (e.g., what language/framework to use if not specified), you must state this in a `plan` step and ask the user for clarification before proceeding with actions.
* **Completeness:** Continue the Plan -> Action -> Observe cycle until the user's request is fully satisfied or determined to be impossible with the available tools.
* **Final Output:** Once the task is completed, provide a clear summary of what was done and confirm successful execution using the final `output` step format. If the final output is code itself, provide it in a code block after the final `output` JSON.

**Output JSON Format:**

* **For Planning Steps & Final Output:**
    ```json
    {
      "step": "plan" or "output",
      "content": "Your thought process, next planned step, or final message to the user."
    }
    ```
* **For Action Steps (Tool Calls):**
    ```json
    {
      "step": "action",
      "function": "tool_name", // e.g., "run_command" or "write_to_file"
      "input": "command_string" or { "file_path": "...", "content": "..." } // Input format depends on the tool
    }
    ```
* **Observation:** The system will provide the observation based on your action. You will process this and generate the next step (plan or final output).

**Example Interaction Flow (Illustrative - similar to yours but reinforcing the cycle):**

User Query: Create a simple "Hello, World!" Python script in a folder called `my_script`.

`{{ "step": "plan", "content": "The user wants a Python script. I need to create a directory first, then create the Python file inside it, and write the 'Hello, World!' code to the file." }}`
`{{ "step": "plan", "content": "First step is to create the directory 'my_script' using run_command." }}`
`{{ "step": "action", "function": "run_command", "input": "mkdir my_script" }}`
*(System provides Observation: {"observe": {"output": ""}} - or similar success indicator)*
`{{ "step": "plan", "content": "Directory 'my_script' created successfully. Now, create the Python file 'hello.py' inside 'my_script' using write_to_file." }}`
`{{ "step": "action", "function": "write_to_file", "input": { "file_path": "my_script/hello.py", "content": "print(\"Hello, World!\")" } }}`
*(System provides Observation: {"observe": {"output": "File written successfully."}} - or similar)*
`{{ "step": "plan", "content": "File 'hello.py' created and content written. The task is complete." }}`
`{{ "step": "output", "content": "The 'Hello, World!' Python script 'hello.py' has been created in the 'my_script' directory." }}`

This detailed prompt provides a clear framework for the AI, defining its role, how it should think and operate using the provided tools, and outlining the specific rules and expected output formats.
```

"""

# Initialize messages with persistent history
Messages = load_history()
system_prompt = """[Your existing system prompt here]"""

try:
    while True:
        user_query = input("> ")
        Messages.append({"role": "user", "content": user_query})
        
        while True:
            try:
                response = client.chat.completions.create(
                    model="gemini-2.0-flash",
                    response_format={"type": "json_object"},
                    messages=Messages
                )
                
                parsed_response = json.loads(response.choices[0].message.content)
                Messages.append({"role": "assistant", "content": json.dumps(parsed_response)})
                save_history(Messages)  # Save after each step
                
                if parsed_response.get("step") == "plan":
                    print(f"🧠: {parsed_response.get('content')}")
                    time.sleep(5)
                    
                elif parsed_response.get("step") == "action":
                    tool_name = parsed_response.get("function")
                    tool_input = parsed_response.get("input")
                    
                    if tool := avaiable_tools.get(tool_name):
                        try:
                            if tool_name == "write_to_file":
                                output = tool["fn"](
                                    tool_input.get("file_path"),
                                    tool_input.get("content")
                                )
                            else:
                                output = tool["fn"](tool_input)
                                
                            Messages.append({
                                "role": "assistant",
                                "content": json.dumps({
                                    "step": "observe",
                                    "output": output
                                })
                            })
                            save_history(Messages)
                            time.sleep(7)
                            
                        except Exception as e:
                            error_msg = f"Tool execution failed: {str(e)}"
                            Messages.append({
                                "role": "assistant",
                                "content": json.dumps({
                                    "step": "observe",
                                    "output": error_msg
                                })
                            })
                            save_history(Messages)
                            raise
                    else:
                        raise ValueError(f"Unknown tool: {tool_name}")
                    
                elif parsed_response.get("step") == "output":
                    print(f"🤖: {parsed_response.get('content')}")
                    break
                    
            except Exception as e:
                print(f"⚠️ Error occurred: {str(e)}")
                print("Restarting conversation loop...")
                Messages.append({
                    "role": "system",
                    "content": "Error occurred, attempting recovery..."
                })
                save_history(Messages)
                break  # Restart inner loop

except KeyboardInterrupt:
    print("\nProgram terminated by user")
finally:
    save_history(Messages)